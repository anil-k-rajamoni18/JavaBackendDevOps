# Monitoring, Logging & Debugging 🩺📊

Kubernetes provides powerful observability tools to monitor, log, and debug workloads. These insights are essential for keeping applications healthy and performant.

---

## 📋 Logging & Monitoring Basics in Kubernetes

Logging and monitoring in Kubernetes help you:
- Understand system behavior over time ⏳
- Detect anomalies 🛑
- Investigate performance or availability issues 🔍

### 🧠 Key Concepts:
- **Logs** are generated by pods and nodes.
- **Metrics** reflect system health like CPU/memory usage.
- Logs are ephemeral; centralized logging is key.


**Monitoring(Metrics)**: 
- involves tracking system metrics like CPU usage, memory usage, and network performance. 
- Provides alerts based on predefined thresholds and conditions
- Monitoring tells us what is happening.

**Logging(Logs)**: 
- involves the collection of log data from various components of a system.
- Logging explains why it is happening.

**Tracing(Traces)**: 
- involves tracking the flow of a request or transaction as it moves through different services and components within a system.
- Tracing shows how it is happening.

### 🤔 Why Monitoring?
- Monitoring helps us keep an eye on our systems to ensure they are working properly.
- Purpose: maintaining the health, performance, and security of IT environments.
- It enables early detection of issues, ensuring that they can be addressed before causing significant downtime or data loss.
- We use monitoring to:
    - Detect Problems Early
    - Measure Performance
    - Ensure Availability

### 🌍 Real-world Example:
An e-commerce platform uses metrics to autoscale services during flash sales and logs to trace order issues.

---

## Metrics vs Monitoring

- Metrics are measurements or data points that tell you what is happening. 
  - For example, the number of steps you walk each day, your heart rate, or the temperature outside—these are all metrics.

- Monitoring is the process of keeping an eye on these metrics over time to understand what’s normal, identify changes, and detect problems. 
  - It's like watching your step count daily to see if you're meeting your fitness goal or checking your heart rate to make sure it's in a healthy range.

## 🚀 Prometheus
- Prometheus is an open-source systems monitoring and alerting toolkit originally built at SoundCloud.
- It is known for its robust data model, powerful query language (PromQL), and the ability to generate alerts based on the collected time-series data.
- It can be configured and set up on both bare-metal servers and container environments like Kubernetes.

## 🏠 Prometheus Architecture
- The architecture of Prometheus is designed to be highly flexible, scalable, and modular.
- It consists of several core components, each responsible for a specific aspect of the monitoring process.

![Prometheus Architecture](https://github.com/iam-veeramalla/observability-zero-to-hero/raw/main/day-2/images/prometheus-architecture.gif)

### 🔥 Prometheus Server
- Prometheus server is the core of the monitoring system. It is responsible for scraping metrics from various configured targets, storing them in its time-series database (TSDB), and serving queries through its HTTP API.
- Components:
    - **Retrieval**: This module handles the scraping of metrics from endpoints, which are discovered either through static configurations or dynamic service discovery methods.
    - **TSDB (Time Series Database)**: The data scraped from targets is stored in the TSDB, which is designed to handle high volumes of time-series data efficiently.
    - **HTTP Server**: This provides an API for querying data using PromQL, retrieving metadata, and interacting with other components of the Prometheus ecosystem.
- **Storage**: The scraped data is stored on local disk (HDD/SSD) in a format optimized for time-series data.

### 🌐 Service Discovery
- Service discovery automatically identifies and manages the list of scrape targets (i.e., services or applications) that Prometheus monitors.
- This is crucial in dynamic environments like Kubernetes where services are constantly being created and destroyed.
- Components:
    - **Kubernetes**: In Kubernetes environments, Prometheus can automatically discover services, pods, and nodes using Kubernetes API, ensuring it monitors the most up-to-date list of targets.
    - **File SD (Service Discovery)**: Prometheus can also read static target configurations from files, allowing for flexibility in environments where dynamic service discovery is not used.

### 📤 Pushgateway
- The Pushgateway is used to expose metrics from short-lived jobs or applications that cannot be scraped directly by Prometheus.
- These jobs push their metrics to the Pushgateway, which then makes them available for Prometheus to scrape(pull).
- Use Case:
    - It's particularly useful for batch jobs or tasks that have a limited lifespan and would otherwise not have their metrics collected.

### 🚨 Alertmanager
- The Alertmanager is responsible for managing alerts generated by the Prometheus server.
- It takes care of deduplicating, grouping, and routing alerts to the appropriate notification channels such as PagerDuty, email, or Slack.

### 🧲 Exporters
- Exporters are small applications that collect metrics from various third-party systems and expose them in a format Prometheus can scrape. They are essential for monitoring systems that do not natively support Prometheus.
- Types of Exporters:
    - Common exporters include the Node Exporter (for hardware metrics), the MySQL Exporter (for database metrics), and various other application-specific exporters.

### 🖥️ Prometheus Web UI
- The Prometheus Web UI allows users to explore the collected metrics data, run ad-hoc PromQL queries, and visualize the results directly within Prometheus.

### 📊 Grafana
- Grafana is a powerful dashboard and visualization tool that integrates with Prometheus to provide rich, customizable visualizations of the metrics data.

### 🔌 API Clients
- API clients interact with Prometheus through its HTTP API to fetch data, query metrics, and integrate Prometheus with other systems or custom applications.

---

## 📈 Setting up Prometheus & Grafana for Metrics

Prometheus scrapes metrics from Kubernetes objects, and Grafana visualizes them through dashboards.

### 🔧 Setup Flow:
1. Deploy **Prometheus Operator**
2. Configure **ServiceMonitors** to scrape metrics
3. Connect Prometheus to **Grafana**

### 📸 Prometheus Deployment Example:
```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: my-service-monitor
spec:
  selector:
    matchLabels:
      app: my-app
  endpoints:
  - port: web
```

### 🌍 Real-world Example:
A ride-sharing app uses Grafana dashboards to visualize trip volume and latency by city.

![Grafana Dashboard](https://grafana.com/static/img/docs/grafana-dashboard-example.png)

---

## 🪵 Fluentd, ELK Stack for Centralized Logging

Centralized logging stacks capture, parse, and store logs from all Kubernetes pods.

### 🔧 Components:
- **Fluentd**: Log aggregator
- **Elasticsearch**: Search and storage engine
- **Kibana**: Visualization UI

### 📸 Fluentd DaemonSet Example:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd
spec:
  selector:
    matchLabels:
      name: fluentd
  template:
    metadata:
      labels:
        name: fluentd
    spec:
      containers:
      - name: fluentd
        image: fluent/fluentd:v1.14-1
        volumeMounts:
        - name: varlog
          mountPath: /var/log
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
```

### 🌍 Real-world Example:
A streaming service uses the ELK stack to analyze 500k+ log lines per second for performance and security auditing.

![ELK Stack](https://logz.io/wp-content/uploads/2019/03/ELK-Stack-Architecture-Diagram.png)

---

## 🐞 Debugging Applications in Kubernetes

Debugging involves inspecting failing pods, checking events, or entering containers.

### 🔍 Key Tools:
- `kubectl describe pod` → Inspect pod events
- `kubectl get events` → See cluster-wide issues
- `kubectl get pod -o wide` → Debug scheduling issues

### 🌍 Real-world Example:
A payment gateway identifies failed card transactions by inspecting crashlooping pods and pod events.

---

## 🛠️ Using kubectl logs & exec for Troubleshooting

### 📜 `kubectl logs`:
Used to view logs from containers.
```bash
kubectl logs my-pod
kubectl logs -f my-pod -c my-container
```

### 🧳 `kubectl exec`:
Used to execute commands in running containers.
```bash
kubectl exec -it my-pod -- /bin/bash
```

### 🌍 Real-world Example:
DevOps engineers run `kubectl exec` to explore misconfigured environment variables causing login failures in production.

![Debugging Tools](https://kubernetes.io/images/docs/kubectl-debug-illustration.png)

---

## 📌 Summary
| Feature         | Tooling           | Benefit                              |
|------------------|--------------------|----------------------------------------|
| Logging          | Fluentd, ELK Stack | View application and system logs       |
| Monitoring       | Prometheus, Grafana| Track CPU, memory, custom metrics      |
| Debugging        | kubectl tools      | Root cause analysis and live debugging |

---

## 📚 Reference Documentation
- [Kubernetes Monitoring Overview](https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/)
- [Prometheus Operator](https://github.com/prometheus-operator/prometheus-operator)
- [Grafana](https://grafana.com/docs/)
- [Fluentd](https://docs.fluentd.org/)
- [ELK Stack](https://www.elastic.co/what-is/elk-stack)
- [kubectl Troubleshooting](https://kubernetes.io/docs/tasks/debug/debug-application/)

---

